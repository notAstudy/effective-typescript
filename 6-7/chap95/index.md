# 선택한 items

<details>
<summary>item 46 - 타입 선언과 관련된 세 가지 버전 이해하기</summary>
- 특정 라이브러리를 dependencies로 설치하고 타입 관련 정보는 devDependencies 로 설치하는 방법
- 메이저와 마이너 버전이 같고 시멘틱 버전 규칙을 잘 지킨다 가정할 때, 타입 버전을 업데이트 할 필요는 없다. 하지만 타입 버전에도 버그가 있을 수 있으니 유의할 것
  
위와 같은 경우는 라이브러리 버전과 타입 버전이 따로 관리되는 경우인데 이는 4가지 문제점을 가지고 있다.
  
1. 라이브러리를 업데이트 했지만 타입 버전은 업데이트 하지않은 경우
-> 보강기법이나 사용하려는 타입을 직접 만들어주는 방법

2. 라이브러리 버전보다 타입 버전이 최신일 경우
   -> 라이브러리 업데이트 또는 타입 버전 다운그레이드

3. 프로젝트에서 사용하는 타입스크립트 버전보다 라이브러리에서 필요로 하는 타입 버전이 최신인 경우
   -> 타입스크립트 업데이트, 라이브러리 타입스크립 버전 다운그레이드, `declare module` 키워드를 사용하서 라이브러리의 타입 정보 없애기

4. `@types` 의존성이 중복될 수 있다.
   -> 대부분의 라이브러리는 타입을 번들리 해서 사용한다. 번들링을 통해서 의존성 중복을 막을 수 있지만 또 다른 4가지 문제점을 발생시킨다.
   <br />
   4-1)보강기법으로 해결할 수 없는 오류가 있는 경우, 타입스크립트 버전이 업그레드 되면서 잘 동작하던 것이 오류 나는 경우 `@types` 를 사용했다면 버전을 자체적으로 맞춰줄 수 있지만 번들된 타입에서는 버전 선택이 불가능하다.
   4-2)프로젝트의 타입이 다른 라이브러리 타입에 의존하는 경우
   보통 dependency는 `devDependencies` 에 들어가게 되는데 프로젝트를 배포하면 `devDependencies`는 설치되지 않을 것이고 오류가 발생한다.
   4-3)과거 버전에서 문제가 있는 경우, 해당 버전으로 돌아가 패치 업데이틀를 진행해야한다. 하지만 번들링 된 타입에서는 어려운 일
   4-4)타입 버전의 패치 업데이트를 자주 할 수 없다.

위와 같은 이유 때문에 타입 선언을 자체적으로 포함하는 방식과 `@types` 로 따로 관리하는 방식을 잘 선택해야한다. 보통 타입스크립트로 라이브러리가 작성되면 타입 선언을 내포하는 방식을 권장한다.

</details>

<details>
<summary>item 48 - API 주석에 TSDoc 사용하기</summary>
</details>
